# Distributed File System
Creating a distributed, fault tolerant file system in Java. When it works, it should replicate data across multiple servers and repair pieces of files that have become corrupt.

## How to try it out
I've been using a Macbook running Catalina to develop this code, and as such have used SDKMAN! to install the necessary packages. *sdk current* tells me I'm using Gradle 7.4.2 and Java 17.0.2-tem, both of which work for me. I haven't tested how much leniency there is with respect to how current Gradle and Java must be to run this code, but probably I'd say having a newish version of Gradle is more important than Java. 

The *Controller*, one of the three types of nodes in the program, has been written to identify the local IP address of its machine so that it may bind to it. Since the *ChunkServer* and the *Client* are designed to communicate with the *Controller*, line 17 of 'ChunkServer.java' and line 28 of 'Client.java', each located in the 'node' subdirectory of the 'src' folder, must be modified before compilation to be the same IP to that which the *Controller* binds. You can find this IP by executing *ifconfig* in a macOS terminal window. This is what my local IP looks like: 192.168.68.59. Once those two lines of code have been correctly modified, open a terminal and navigate to the highest directory of the project, which contains the 'build', 'libs', and 'src' folders. 

I've written a script called 'osx.sh' for the project, which automates the running of the project's components. To use the script, run *./osx.sh* in the terminal window. This will use Gradle to clean and build the project. Next it will start the *Controller* node in the current terminal window, and spawn two new terminal windows. In one of the new terminal windows, run *./osx.sh*. This will, in this new window, open nine terminal tabs, and create a *ChunkServer* in each of them. Wait for new terminal tabs to stop spawning before you navigate to the last terminal window. The last terminal window will be the window used for the *Client*. The *Client* can either use **erasure coding** or **replication** as a storage technique. To use erasure coding, run *./osx.sh c erasure*, to use replication, run *./osx.sh c replication*. 

If you've followed the directions correctly, and my directions are clear, you should have open three terminal windows. One will contain the *Controller*, which will be printing out data associated with the connections it has made with the *ChunkServers*. Another will contain ten terminal tabs, nine of which are each associated with a specific *ChunkServer*. Each *ChunkServer* will print its IP address and port, along with information regarding the regular heartbeats it sends to the *Controller*. The last window will contain the *Client*, which will be waiting for a command from the user. 

The *Client* offers directions on how to it is to be used when you run the 'help' command (or when it is given a known command with improper usage).

## A quick overview

This project is an assignment taken from a graduate course in distributed systems at CSU. I haven't taken the course, but I took its undergraduate prerequisite during my senior year. Since I haven't attended the lectures or the recitations, I can't guarantee that my work for this projects meets the unmentioned-in-the-assignment-description-but-tested-in-their-grading requirements. This project involves a lot of code (at least for me) with a bunch of interacting parts, so there will be behavior that is unexpected if the right inputs are supplied.

As was briefly mentioned in the *How to try it out* section, the project is based around three types of nodes -- a node being a computer in a network executing a specific program from the project. The three types of nodes are the *Controller*, the *ChunkServer*, and the *Client*.
